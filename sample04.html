<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>sample04</title>
<style>
  .btn {
      display: inline-block;
      margin: 4px;
      padding: 8px;
      background: #81D4FA;
      box-shadow: 2px 2px 4px 0 rgba(0, 0, 0, .5);
  }
  .btn-inactive {
      background: #999999;
  }
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js" integrity="sha512-dLxUelApnYxpLt6K2iomGngnHO83iUvZytA3YjDUCjT0HDOHKXnVYdf3hU4JjM8uEhxf9nD1/ey98U3t2vZ0qQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script src="OrbitControls.js"></script>
<script>
window.addEventListener("load", init);
function init(){

    const canvas = document.querySelector('#rubiks');
    const width = 500;
    const height = 500;

    const renderer = new THREE.WebGLRenderer({canvas, antialias: true});
    renderer.setSize(width, height);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xffffff);

    // X軸: 右方向
    // Y軸: 上方向
    // Z軸: 手前方向

    const colorY = 0xffff00;
    const colorB = 0x0000ff;
    const colorR = 0xff0000;
    const colorG = 0x00ff00;
    const colorO = 0xff8800;
    const colorW = 0xffffff;
    const colorE = 0x000000;

    function createHomeFaces() {
        const faces0 = [
            colorY, // 0 - 8
            colorB, // 9 - 17
            colorR, // 18 - 26
            colorG, // 27 - 35
            colorO, // 36 - 44
            colorW, // 45 - 53
        ];
        const faces = [];
        for (let i = 0; i < 6; i++) {
            for (let j = 0; j < 9; j++) {
                faces.push({color: faces0[i], box: null, rotated: false});
            }
        }
        return faces;
    }

    function copyFaces(faces) {
        const dst = [];
        for (let i = 0; i < 54; i++) {
            const f = faces[i];
            dst.push({color: f.color});
        }
        return dst;
    }

    const faces = createHomeFaces();
    const faces2 = copyFaces(faces);

    const nullRotationAction = {axis: "", direction: [0, 0, 0], speed: 1};
    let rotationAction = nullRotationAction;;
    let rotationActionStartTime = new Date().getTime();
    const actionQueue = [
    ];

    const cubeWidth = 100;
    const cubePadding = 15;
    const faceDepth = 5;
    const rubiksHalfWidth = (cubeWidth * 3 - faceDepth) * 0.5;

    function createBox(color, axis) {
        const material1 = new THREE.MeshBasicMaterial({color: color});
        const material2 = new THREE.MeshBasicMaterial({color: colorE});
        const materials = [material2, material2, material2, material2, material2, material2];
        let w, h, d;
        if (axis == "x") {
            materials[0] = material1;
            materials[1] = material1;
            w = faceDepth;
            h = cubeWidth - cubePadding;
            d = cubeWidth - cubePadding;
        } else if (axis == "y") {
            materials[2] = material1;
            materials[3] = material1;
            w = cubeWidth - cubePadding;
            h = faceDepth;
            d = cubeWidth - cubePadding;
        } else if (axis == "z") {
            materials[4] = material1;
            materials[5] = material1;
            w = cubeWidth - cubePadding;
            h = cubeWidth - cubePadding;
            d = faceDepth;
        }
        const geometry = new THREE.BoxGeometry(w, h, d);
        const box = new THREE.Mesh(geometry, materials);
        return box;
    }

    function replaceBox(face, faceDirection, faceSign, i, j, rot, cos, sin) {
        if (face.rotated) {
            scene.remove(face.box);
            face.rotated = false;
            face.box = null;
        }
        const oldBox = face.box;
        if (oldBox == null) {
            face.box = createBox(face.color, faceDirection);
        }
        const box = face.box;
        let x, y, z;
        if (faceDirection == "x") {
            x = faceSign * rubiksHalfWidth;
            y = (1 - i) * cubeWidth;
            z = faceSign * (1 - j) * cubeWidth;
        } else if (faceDirection == "y") {
            x = (j - 1) * cubeWidth;
            y = faceSign * rubiksHalfWidth;
            z = faceSign * (i - 1) * cubeWidth;
        } else if (faceDirection == "z") {
            x = faceSign * (j - 1) * cubeWidth;
            y = (1 - i) * cubeWidth;
            z = faceSign * rubiksHalfWidth;
        }
        let [rx, ry, rz] = [0, 0, 0];
        if (rotationAction.axis == "x") {
            let directionIdx;
            if (faceDirection == "x") {
                directionIdx = faceSign + 1;
            } else if (faceDirection == "y") {
                directionIdx = j;
            } else if (faceDirection == "z") {
                directionIdx = faceSign * (j - 1) + 1
            }
            const sign = rotationAction.direction[directionIdx];
            if (sign != 0) {
                const y2 = y * cos + z * sin * sign;
                const z2 = z * cos - y * sin * sign;
                y = y2;
                z = z2;
                rx = -sign * rot;
            }
        } else if (rotationAction.axis == "y") {
            let directionIdx;
            if (faceDirection == "x") {
                directionIdx = 2 - i;
            } else if (faceDirection == "y") {
                directionIdx = faceSign + 1;
            } else if (faceDirection == "z") {
                directionIdx = 2 - i;
            }
            const sign = rotationAction.direction[directionIdx];
            if (sign != 0) {
                const z2 = z * cos + x * sin * sign;
                const x2 = x * cos - z * sin * sign;
                z = z2;
                x = x2;
                ry = -sign * rot;
            }
        } else if (rotationAction.axis == "z") {
            let directionIdx;
            if (faceDirection == "x") {
                directionIdx = faceSign * (1 - j) + 1
            } else if (faceDirection == "y") {
                directionIdx = faceSign * (i - 1) + 1
            } else if (faceDirection == "z") {
                directionIdx = faceSign + 1;
            }
            const sign = rotationAction.direction[directionIdx];
            if (sign != 0) {
                const x2 = x * cos + y * sin * sign;
                const y2 = y * cos - x * sin * sign;
                x = x2;
                y = y2;
                rz = -sign * rot;
            }
        }
        box.position.x = x;
        box.position.y = y;
        box.position.z = z;
        box.rotation.x = rx;
        box.rotation.y = ry;
        box.rotation.z = rz;
        if (oldBox == null) {
            scene.add(box);
        }
    }

    function replaceBoxes(rot, cos, sin) {
        for (let i = 0; i < 3; i++) {
            for (let j = 0; j < 3; j++) {
                const idx = 3 * i + j;
                replaceBox(faces[idx], "y", +1, i, j, rot, cos, sin);
            }
        }
        for (let i = 0; i < 3; i++) {
            for (let j = 0; j < 3; j++) {
                const idx = 9 + 3 * i + j;
                replaceBox(faces[idx], "z", +1, i, j, rot, cos, sin);
            }
        }
        for (let i = 0; i < 3; i++) {
            for (let j = 0; j < 3; j++) {
                const idx = 18 + 3 * i + j;
                replaceBox(faces[idx], "x", +1, i, j, rot, cos, sin);
            }
        }
        for (let i = 0; i < 3; i++) {
            for (let j = 0; j < 3; j++) {
                const idx = 27 + 3 * i + j;
                replaceBox(faces[idx], "z", -1, i, j, rot, cos, sin);
            }
        }
        for (let i = 0; i < 3; i++) {
            for (let j = 0; j < 3; j++) {
                const idx = 36 + 3 * i + j;
                replaceBox(faces[idx], "x", -1, i, j, rot, cos, sin);
            }
        }
        for (let i = 0; i < 3; i++) {
            for (let j = 0; j < 3; j++) {
                const idx = 45 + 3 * i + j;
                replaceBox(faces[idx], "y", -1, i, j, rot, cos, sin);
            }
        }
    }

    function actRotation() {
        const [flag, rot, cos, sin] = calcRotationAngle();
        if (flag) {
            rotateFaces(rotationAction, faces);
            if (actionQueue.length == 0) {
                rotationAction = intervalAction(1);
                rotationActionStartTime = 0;
            } else if (rotationAction.axis == "") {
                rotationAction = actionQueue.shift();
                rotationActionStartTime = new Date().getTime();
            } else {
                const speed = Math.min(rotationAction.speed, actionQueue[0].speed);
                rotationAction = intervalAction(speed);
                rotationActionStartTime = new Date().getTime();
            }
            replaceBoxes(rot, cos, sin);
        } else if (rotationAction.axis != "") {
            replaceBoxes(rot, cos, sin);
        }
    }

    function calcRotationAngle() {
        const now = new Date().getTime();
        let d = (now - rotationActionStartTime) * rotationAction.speed * 0.002;
        if (d >= 1.0) {
            return [true, 0.0, 1.0, 0.0];
        } else {
            d = d * 0.5 * Math.PI;
            return [false, d, Math.cos(d), Math.sin(d)];
        }
    }

    function intervalAction(speed) {
        return {axis: "", direction: [0, 0, 0], speed: speed};
    }

    replaceBoxes(0.0, 1.0, 0.0);
    //actRotation();

    const camera = new THREE.PerspectiveCamera(90, width / height, 1, 1000);
    function resetCamera() {
        camera.position.set(250, 250, 400);
        camera.lookAt(scene.position);
    }
    function resetCameraBottom() {
        camera.position.set(250, -250, 400);
        camera.lookAt(scene.position);
    }
    function resetCameraReverse() {
        camera.position.x = -camera.position.x;
        camera.position.y = -camera.position.y;
        camera.position.z = -camera.position.z;
        camera.lookAt(scene.position);
    }
    resetCamera();

    const controls = new THREE.OrbitControls(camera, canvas);
    controls.rotateSpeed = 0.5;
    controls.update();

    renderer.render(scene, camera);

    function animate() {
        requestAnimationFrame(animate);
        actRotation();
        controls.update();
        renderer.render(scene, camera);
    }

    function pushActionToQueue(action) {
        actionQueue.push(action);
        rotateFaces(action, faces2);
    }

    const btnActions = {};
    const keyEventHandlers = {};
    function setActionBtnClickEvent(id, key, actions) {
        const handler = function(event) {
            let acts;
            if (typeof(actions) == "function") {
                acts = actions();
            } else {
                acts = actions;
            }
            for (const act of acts) {
                pushActionToQueue(act);
            }
            activateBtns();
            if (event) {
                event.preventDefault();
            }
            return false;
        };

        document.getElementById(id).addEventListener("click", handler);

        btnActions[id] = actions;
        if (key != "") {
            keyEventHandlers[key] = handler;
        }
    }

    function activateBtns() {
        for (const id in btnActions) {
            const actions = btnActions[id];
            if (typeof(actions) == "function") {
                acts = actions();
                if (acts.length == 0) {
                    document.getElementById(id).classList.add("btn-inactive");
                } else {
                    document.getElementById(id).classList.remove("btn-inactive");
                }
            }
        }
    }

    document.getElementById("reset-camera").addEventListener("click", function(event) {
        resetCamera();
        event.preventDefault();
        return false;
    });
    document.getElementById("reset-camera-bottom").addEventListener("click", function(event) {
        resetCameraBottom();
        event.preventDefault();
        return false;
    });
    document.getElementById("reset-camera-reverse").addEventListener("click", function(event) {
        resetCameraReverse();
        event.preventDefault();
        return false;
    });

    document.body.addEventListener("keydown", function(event) {
        const handler = keyEventHandlers[event.key];
        if (handler) {
            handler();
        }
    });

    //--------------------------------------------------------------------------------

    function rotateFaces(rotationAction, faces) {
        function rotate1(i1, i2, i3, i4) {
            const tmp = faces[i1];
            faces[i1] = faces[i4];
            faces[i4] = faces[i3];
            faces[i3] = faces[i2];
            faces[i2] = tmp;
            faces[i1].rotated = true;
            faces[i2].rotated = true;
            faces[i3].rotated = true;
            faces[i4].rotated = true;
        }
        function rotate2(idx) {
            rotate1(idx    , idx + 2, idx + 8, idx + 6);
            rotate1(idx + 1, idx + 5, idx + 7, idx + 3);
        }
        function rotateFacesX(directionIdx) {
            rotate1(     directionIdx, 35 - directionIdx, 45 + directionIdx,  9 + directionIdx);
            rotate1( 3 + directionIdx, 32 - directionIdx, 48 + directionIdx, 12 + directionIdx);
            rotate1( 6 + directionIdx, 29 - directionIdx, 51 + directionIdx, 15 + directionIdx);
            if (directionIdx == 0) {
                rotate2(36);
                rotate2(36);
                rotate2(36);
            } else if (directionIdx == 2) {
                rotate2(18);
            }
        }
        function rotateFacesY(directionIdx) {
            rotate1(15 - 3 * directionIdx, 42 - 3 * directionIdx, 33 - 3 * directionIdx, 24 - 3 * directionIdx);
            rotate1(16 - 3 * directionIdx, 43 - 3 * directionIdx, 34 - 3 * directionIdx, 25 - 3 * directionIdx);
            rotate1(17 - 3 * directionIdx, 44 - 3 * directionIdx, 35 - 3 * directionIdx, 26 - 3 * directionIdx);
            if (directionIdx == 0) {
                rotate2(45);
                rotate2(45);
                rotate2(45);
            } else if (directionIdx == 2) {
                rotate2(0);
            }
        }
        function rotateFacesZ(directionIdx) {
            rotate1(     3 * directionIdx, 20 - directionIdx, 53 - 3 * directionIdx, 42 + directionIdx);
            rotate1( 1 + 3 * directionIdx, 23 - directionIdx, 52 - 3 * directionIdx, 39 + directionIdx);
            rotate1( 2 + 3 * directionIdx, 26 - directionIdx, 51 - 3 * directionIdx, 36 + directionIdx);
            if (directionIdx == 0) {
                rotate2(27);
                rotate2(27);
                rotate2(27);
            } else if (directionIdx == 2) {
                rotate2(9);
            }
        }
        let r = null;
        if (rotationAction.axis == "x") {
            r = rotateFacesX;
        } else if (rotationAction.axis == "y") {
            r = rotateFacesY;
        } else if (rotationAction.axis == "z") {
            r = rotateFacesZ;
        }
        if (r) {
            for (let i = 0; i < 3; i++) {
                if (rotationAction.direction[i] == +1) {
                    r(i);
                } else if (rotationAction.direction[i] == -1) {
                    r(i);
                    r(i);
                    r(i);
                }
            }
        }
    }

    setActionBtnClickEvent("action-r1", "r", [{axis: "x", direction: [ 0,  0, +1], speed: 1}]);
    setActionBtnClickEvent("action-r3", "R", [{axis: "x", direction: [ 0,  0, -1], speed: 1}]);
    setActionBtnClickEvent("action-l1", "l", [{axis: "x", direction: [-1,  0,  0], speed: 1}]);
    setActionBtnClickEvent("action-l3", "L", [{axis: "x", direction: [+1,  0,  0], speed: 1}]);
    setActionBtnClickEvent("action-u1", "u", [{axis: "y", direction: [ 0,  0, +1], speed: 1}]);
    setActionBtnClickEvent("action-u3", "U", [{axis: "y", direction: [ 0,  0, -1], speed: 1}]);
    setActionBtnClickEvent("action-f1", "f", [{axis: "z", direction: [ 0,  0, +1], speed: 1}]);
    setActionBtnClickEvent("action-f3", "F", [{axis: "z", direction: [ 0,  0, -1], speed: 1}]);

    setActionBtnClickEvent("action-d1", "d", [{axis: "y", direction: [-1,  0,  0], speed: 1}]);
    setActionBtnClickEvent("action-d3", "D", [{axis: "y", direction: [+1,  0,  0], speed: 1}]);
    setActionBtnClickEvent("action-b1", "b", [{axis: "z", direction: [-1,  0,  0], speed: 1}]);
    setActionBtnClickEvent("action-b3", "B", [{axis: "z", direction: [+1,  0,  0], speed: 1}]);
    setActionBtnClickEvent("action-m1", "m", [{axis: "x", direction: [ 0, -1,  0], speed: 1}]);
    setActionBtnClickEvent("action-m3", "M", [{axis: "x", direction: [ 0, +1,  0], speed: 1}]);

    setActionBtnClickEvent("action-x1", "x", [{axis: "x", direction: [+1, +1, +1], speed: 1}]);
    setActionBtnClickEvent("action-x3", "X", [{axis: "x", direction: [-1, -1, -1], speed: 1}]);
    setActionBtnClickEvent("action-y1", "y", [{axis: "y", direction: [+1, +1, +1], speed: 1}]);
    setActionBtnClickEvent("action-y3", "Y", [{axis: "y", direction: [-1, -1, -1], speed: 1}]);
    setActionBtnClickEvent("action-z1", "z", [{axis: "z", direction: [+1, +1, +1], speed: 1}]);
    setActionBtnClickEvent("action-z3", "Z", [{axis: "z", direction: [-1, -1, -1], speed: 1}]);

    setActionBtnClickEvent("action-shuffle", "", function() {
        const actions = [];
        const speed = 6;
        for (let i = 0; i < 15; i++) {
            let axis = Math.floor(Math.random() * 3);
            if (axis == 0) {
                axis = "x";
            } else if (axis == 1) {
                axis = "y";
            } else {
                axis = "z";
            }
            const direction = [
                Math.floor(Math.random() * 3 - 1),
                Math.floor(Math.random() * 3 - 1),
                Math.floor(Math.random() * 3 - 1),
            ];
            actions.push({axis, direction, speed});
        }
        return actions;
    });

    setActionBtnClickEvent("action-yello-to-top", "", function() {
        let futureFaces = copyFaces(faces2);
        const actions = [];
        const speed = 1;
        function pushAction(action) {
            actions.push(action);
            rotateFaces(action, futureFaces);
        }
        while (true) {
            if (futureFaces[13].color == colorY) {
                pushAction({axis: "x", direction: [+1, +1, +1], speed});
                continue;
            }
            if (futureFaces[22].color == colorY) {
                pushAction({axis: "z", direction: [-1, -1, -1], speed});
                continue;
            }
            if (futureFaces[31].color == colorY) {
                pushAction({axis: "x", direction: [-1, -1, -1], speed});
                continue;
            }
            if (futureFaces[40].color == colorY) {
                pushAction({axis: "z", direction: [+1, +1, +1], speed});
                continue;
            }
            if (futureFaces[49].color == colorY) {
                pushAction({axis: "x", direction: [+1, +1, +1], speed});
                continue;
            }

            if (futureFaces[22].color == colorB) {
                pushAction({axis: "y", direction: [+1, +1, +1], speed});
                continue;
            }
            if (futureFaces[31].color == colorB) {
                pushAction({axis: "y", direction: [+1, +1, +1], speed});
                continue;
            }
            if (futureFaces[40].color == colorB) {
                pushAction({axis: "y", direction: [-1, -1, -1], speed});
                continue;
            }

            break;
        }
        return actions;
    });

    //--------------------------------------------------------------------------------

    animate();
    activateBtns();

}

</script>
</head>
<body>

  <canvas id="rubiks"></canvas>

  <div>
    <a href="#" id="action-r1" class="btn">R</a>
    <a href="#" id="action-r3" class="btn">R'</a>
    <a href="#" id="action-l1" class="btn">L</a>
    <a href="#" id="action-l3" class="btn">L'</a>
    <a href="#" id="action-u1" class="btn">U</a>
    <a href="#" id="action-u3" class="btn">U'</a>
    <a href="#" id="action-f1" class="btn">F</a>
    <a href="#" id="action-f3" class="btn">F'</a>
  </div>
  <div>
    <a href="#" id="action-d1" class="btn">D</a>
    <a href="#" id="action-d3" class="btn">D'</a>
    <a href="#" id="action-b1" class="btn">B</a>
    <a href="#" id="action-b3" class="btn">B'</a>
    <a href="#" id="action-m1" class="btn">M</a>
    <a href="#" id="action-m3" class="btn">M'</a>
  </div>
  <div>
    <a href="#" id="action-x1" class="btn">X</a>
    <a href="#" id="action-x3" class="btn">X'</a>
    <a href="#" id="action-y1" class="btn">Y</a>
    <a href="#" id="action-y3" class="btn">Y'</a>
    <a href="#" id="action-z1" class="btn">Z</a>
    <a href="#" id="action-z3" class="btn">Z'</a>
  </div>
  <div>
    <a href="#" id="action-shuffle" class="btn">シャッフル</a>
  </div>
  <div>
    <a href="#" id="action-yello-to-top" class="btn">黄を上に</a>
  </div>

  <p>
    <a href="#" id="reset-camera">視点をリセット</a>
    <a href="#" id="reset-camera-bottom">視点を下から</a>
    <a href="#" id="reset-camera-reverse">視点を反対側から</a>
  </p>
</body>
</html>
